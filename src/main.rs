// Include the generated bindings from build.rs
//include!(concat!(env!("OUT_DIR"), "/rocblas_bindings.rs"));
mod rocblas_bindings;
mod hip_bindings;

use rocblas_bindings::*;
use hip_bindings::*;

use num_complex::Complex;
use std::ptr;
use std::mem;
use std::ffi::c_void;
use std::cmp::min;
use std::time::{Instant};
use std::mem::ManuallyDrop;

fn print_hex_bytes<T>(value: T) 
where
    T: Copy,
{
    // Convert the value to a byte slice
    let bytes: &[u8] = unsafe {
        // Unsafe block needed for `transmute` to convert the value to bytes
        std::slice::from_raw_parts(
            &value as *const T as *const u8,
            std::mem::size_of::<T>(),
        )
    };

    // Print the bytes in hexadecimal format
    for byte in bytes {
        print!("{:02x} ", byte);
    }
    println!();
}

//    print_hex_bytes(value);  // Example with f32

fn main() {
    // Initialize a handle for rocBLAS (this will be part of the bindings generated by bindgen)
    let args: Vec<String> = std::env::args().collect();
    if args.len() < 2 {
        eprintln!("Usage: {} <matrix_size>", args[0]);
        std::process::exit(1);
    }
    // Parse the argument as an integer
    let input_size: usize = match args[1].parse() {
        Ok(num) => num,
        Err(_) => {
            eprintln!("Please provide a valid integer.");
            return;
        }
    };
    // Lots of amdgpu page faults on rocblas init. Seems ok to ignore them for now.
    unsafe {
        rocblas_initialize();
    }
    println!("init done");
    
    // Create the handle
    let mut handle: rocblas_handle = ptr::null_mut();
    unsafe {
        let status = rocblas_bindings::rocblas_create_handle(&mut handle);
        println!("status of create_handle: {:?}", status);
    }
    println!("handle: {:?} ", handle);
    let size1: usize = 0;
    let mut size2: usize = 0;

    let complex1: Complex<f32> = Complex::<f32>::new(3.01967, 3.0);
    print_hex_bytes(complex1);
    let complex2: rocblas_bindings::rocblas_float_complex = rocblas_float_complex { x:3.01967, y:3.0};
    print_hex_bytes(complex2);
    // Matrix dimensions taken from the command line arg[1];
    let m = input_size;
    let n = input_size;
    let k = input_size;
    let size1: usize = m as usize * n as usize;
    let elem_size1 = mem::size_of::<Complex<f32>>();
    let size1_f: f32 = size1 as f32;
    let elem_size1_f: f32 = elem_size1 as f32;
    let ram_size: f32 = size1_f * elem_size1_f / 1000000.0;
    println!("matrix rows: {} cols: {} size: {} ram: {} MB", m, n, size1, ram_size);
    size2 = min(16, size1);
 
    let gpu1: *mut c_void = ptr::null_mut();
    let gpu2: *mut c_void = ptr::null_mut();
    let gpu3: *mut c_void = ptr::null_mut();
    let mut a: ManuallyDrop<Vec<Complex<f32>>>;
    let mut b: ManuallyDrop<Vec<Complex<f32>>>;
    let mut c: ManuallyDrop<Vec<Complex<f32>>>;
    unsafe {
        let error1: hip_bindings::hipError_t = hip_bindings::hipMalloc(&gpu1 as *const *mut c_void, size1 * mem::size_of::<Complex<f32>>() );
        println!("hipMalloc1: {:?}", error1);
        if error1 != hipError_t_hipSuccess {
            return;
        }
        let error1: hip_bindings::hipError_t = hip_bindings::hipMalloc(&gpu2 as *const *mut c_void, size1 * mem::size_of::<Complex<f32>>() );
        println!("hipMalloc2: {:?}", error1);
        if error1 != hipError_t_hipSuccess {
            return;
        }
        let error1: hip_bindings::hipError_t = hip_bindings::hipMalloc(&gpu3 as *const *mut c_void, size1 * mem::size_of::<Complex<f32>>() );
        println!("hipMalloc3: {:?}", error1);
        if error1 != hipError_t_hipSuccess {
            return;
        }
        a = ManuallyDrop::new(Vec::from_raw_parts(gpu1 as *mut Complex<f32>, size1, size1));
        b = ManuallyDrop::new(Vec::from_raw_parts(gpu2 as *mut Complex<f32>, size1, size1));
        c = ManuallyDrop::new(Vec::from_raw_parts(gpu3 as *mut Complex<f32>, size1, size1));
    }

    for i in 0..size1 { // This loops till size-1.
        a[i] = Complex::<f32>::new(2.0, 0.0);
    }
    for i in 0..size1 { // This loops till size-1.
        b[i] = Complex::<f32>::new(2.0, 0.0);
    }
    println!("Matrix A (input): ");
    for i in 0..size2 { // This loops till size-1.
        print!("{} ", a[i]);
    }
    println!("");
    print_hex_bytes(a[0]);
    println!("Matrix B (input): ");
    for i in 0..size2 { // This loops till size-1.
        print!("{} ", b[i]);
    }
    println!("");
    print_hex_bytes(b[0]);
    println!("Matrix C (input): ");
    for i in 0..size2 { // This loops till size-1.
        print!("{} ", c[i]);
    }
    println!("");

    let elem_size: i32 = mem::size_of::<Complex<f32>>() as i32;
    println!("elem_size for a complex f32: {:?}", elem_size);

    // Call gemm to perform matrix multiplication: C = A * B
    let alpha: rocblas_bindings::rocblas_float_complex = rocblas_float_complex { x:1.0, y:0.0};
    let beta: rocblas_bindings::rocblas_float_complex = rocblas_float_complex { x:0.0, y:0.0};
    let elem_size2: usize = mem::size_of::<rocblas_bindings::rocblas_float_complex>() as usize;
    let elem_size2_f: f32 = elem_size2 as f32;
    let ram_size2: f32 = size1_f * elem_size2_f / 1000000.0;
    println!("elem_size for cgemm: {:?}", elem_size2);
    println!("matrix rows: {} cols: {} size: {} ram: {} MB", m, n, size1, ram_size2);
    println!("Start calc1 -------------------");

    let mut gemm_status: rocblas_status = 99;
    let start6 = Instant::now();
    unsafe {
        gemm_status = rocblas_cgemm(
            handle, 
            rocblas_operation__rocblas_operation_none, // No transpose for A
            rocblas_operation__rocblas_operation_none, // No transpose for B
            m as i32, 
            n as i32, 
            k as i32, 
            &alpha as *const rocblas_bindings::rocblas_float_complex, 
            a.as_ptr() as *const rocblas_float_complex, 
            m as i32, 
            b.as_ptr() as *const rocblas_float_complex, 
            k as i32, 
            &beta as *const rocblas_bindings::rocblas_float_complex, 
            c.as_ptr() as *mut rocblas_float_complex, 
            m as i32
        );
    }
    let duration6= start6.elapsed();
    println!("End calc1 -------------------");
    if gemm_status != rocblas_status__rocblas_status_success {
        println!("rocBLAS gemm operation failed!");
    }

    println!("Start sync -------------------");
    let mut error1: hip_bindings::hipError_t = 9999;
    let start7 = Instant::now();
    unsafe {
        error1 = hipDeviceSynchronize();
    }
    let duration7= start7.elapsed();
    println!("hipSyncError: {:?}", error1);
    if error1 != 0 {
        return;
    }
    println!("End sync -------------------");
    println!("Start get results -------------------");
    println!("End get results -------------------");
    for i in 0..size2 { // This loops till size-1.
        print!("{} ", c[i]);
    }
    println!("");
    println!("calc1:       {:?}", duration6);
    println!("sync:        {:?}", duration7);
}


